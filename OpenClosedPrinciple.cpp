#include <iostream>
#include <cmath>
using namespace std;

// базовий клас фігури
class Figure {
public:
    virtual double getArea() = 0; // метод обчислення площі (чисто віртуальний метод)
};

// клас прямокутника
class Rectangle : public Figure {
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    double getArea() override {
        return width * height;
    }
};

#define PI 3.1415926
// клас кола
class Circle : public Figure {
    double radius;
public:
    Circle(double r) : radius(r) {}
    double getArea() override {
        return PI * radius * radius;
    }
};

// клас трикутника
class Triangle : public Figure {
    double base, height;
public:
    Triangle(double b, double h) : base(b), height(h) {}
    double getArea() override {
        return 0.5 * base * height;
    }
};

// клас ромба, успадковується від базового класу Figure
class Rhombus : public Figure {
    double d1, d2;
public:
    Rhombus(double diagonal1, double diagonal2) : d1(diagonal1), d2(diagonal2) {}
    double getArea() override {
        return 0.5 * d1 * d2;
    }
};

int main() {
    Figure* figures[4]; // масив покажчиків на об'єкти класів фігур
    figures[0] = new Rectangle(5, 3);
    figures[1] = new Circle(4);
    figures[2] = new Triangle(6, 2);
    figures[3] = new Rhombus(5, 8);
    for (int i = 0; i < 4; i++) {
        cout << "Площа фігури " << i + 1 << ": " << figures[i]->getArea() << endl;
        delete figures[i]; // звільняємо пам'ять
    }
}
/*
ЗАДАЧА:
1. Створіть базовий клас Figure з методом обчислення площі.
2. Реалізуйте декілька класів, що успадковуються від базового класу Figure,
наприклад, класи Rectangle, Circle, Triangle та інші.
3. Перевірте, що кожен клас правильно перевизначає метод обчислення
площі відповідно до особливостей фігури.
4. Тепер додайте новий клас Rhombus, який не може бути виражений через
прямокутник, коло чи трикутник.
5. Реалізуйте принцип відкритості/закритості, не змінюючи код у наявних
класах. Для цього створіть новий клас Rhombus, який успадковується
від базового класу Figure і перевизначає метод обчислення площі.
6. Перевірте, що ваш код працює правильно, викликаючи метод обчислення площі
для об'єктів різних класів фігур.
*/
/*
Принцип Open Closed Principle виражений у цьому коді через використання
успадкування та поліморфізму. Клас Figure є базовим класом,
який визначає метод getArea() для обчислення площі фігури. Класи
Rectangle, Circle і Triangle успадковуються від класу Figure і перевизначають
метод getArea() відповідно до особливостей кожної фігури.
Додавання нового класу Rhombus, який не може бути виражений через
прямокутник, коло чи трикутник, не вимагає зміни коду в наявних
класах. Натомість створюється новий клас Rhombus, який також успадковується
від класу Figure і перевизначає метод getArea() для обчислення площі ромба.
Таким чином, принцип Open Closed Principle полягає в тому, що класи
мають бути відкриті для розширення (додавання нових класів), але закриті
для зміни (не повинні вимагати зміни в уже наявному коді).
*/
/*
Open/Closed Principle (OCP) – принцип відкритості/закритості (програмні
сутності мають бути відкриті для розширення, але закриті для зміни.
Проблема: треба додати функціональність – доводиться змінювати клас.
А це суперечить ідеї S.O.L.I.D.
Рішення: абстракція та інтерфейсні вказівники.
Сучасне об'єктно-орієнтоване проєктування, не заперечуючи важливість
успадкування, робить ставку на композицію та на передачу інтерфейсних
вказівників, тому, коли ми говоримо про розширення, ми говоримо про
інтерфейсні вказівники. Принцип відкритості/закритості вимагає переходити
від реалізації до абстракції.
Суть принципу OCP в тому, що єдиноразово створені класи не слід змінювати
під конкретні потреби конкретної ситуації.
Для зміни поведінки певного класу необхідно явним чином описати
його інтерфейс і створити іншу реалізацію цього інтерфейсу.
*/
// https://www.youtube.com/watch?v=ph6IIeGTmmw
// BAD: https://gist.github.com/sunmeat/93b6d02fcfe13953f47c9af3598a574b
// GOOD: https://gist.github.com/sunmeat/2478549dbb21550ef4e35671bc5c6b9f
